<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The Reactive Machine on Reactive Machine</title>
    <link>http://reactive-machine.org/docs/</link>
    <description>Recent content in The Reactive Machine on Reactive Machine</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://reactive-machine.org/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Programming Model</title>
      <link>http://reactive-machine.org/docs/model/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model/</guid>
      <description>Orchestrations define how to execute of one or more operations in a sequence, or in parallel. Orchestrations can
 perform Activities which encapsulate calls to external services, or any other nondeterministic behavior. perform Read or Update operations that target a particular state. raise Events that atomically update all subscribed states. specify one or more partition Locks that should be held during execution  States represent a small piece of information (like a key-value pair, or virtual actor).</description>
    </item>
    
    <item>
      <title>Events</title>
      <link>http://reactive-machine.org/docs/model-events/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model-events/</guid>
      <description>(section needs work)
Events provide reliable, consistent pub-sub. When an event is raised by an orchestration, all the states that subscribe to it are modified. Events appear to be globally ordered and virtually synchronous.</description>
    </item>
    
    <item>
      <title>Hosts</title>
      <link>http://reactive-machine.org/docs/hosts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/hosts/</guid>
      <description>(section needs work)</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>http://reactive-machine.org/docs/examples/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/examples/</guid>
      <description>Examples We have several example applications written using the Reactive Machine.
 Hello World The Hello World example serves to verify that youâ€™ve got the Reactive Machine built correctly and can get a basic service up and running. Further examples, like the Echo and Counter examples demonstrate features of the programming model. Echo Service The Echo service example demonstrates how we can build an application that responds to events without the user having to consider failure, partitioning, routing messages or deployment details.</description>
    </item>
    
    <item>
      <title>Motivation</title>
      <link>http://reactive-machine.org/docs/motivation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/motivation/</guid>
      <description>Motivation &amp;amp; Vision With the promise of developer agility, independent operations, and elastic scalability, microservice based development has become the &amp;ldquo;new normal&amp;rdquo; in distributed application development. Developers build application services such as dashboards, client services, and user-accesible APIs by &amp;ldquo;composing&amp;rdquo; existing cloud services, such as storage, databases, queues, and other microservices.
Stateless Microservices However, many modern approaches to elastic scalability rely on an application tier that stateless and volatile. Application state must be loaded at the start of each request, persisted to cloud storage at the end of each request, and cached locally, if the application developer is sure that it will not introduce consistency anomalies.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://reactive-machine.org/docs/examples-hello/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/examples-hello/</guid>
      <description>Hello World The Hello World example serves to verify that you&amp;rsquo;ve got the Reactive Machine built correctly and can get a basic service up and running. Further examples, like the Echo and Counter examples demonstrate features of the programming model.
Definining a service We begin by defining a new service: HelloWorld.Service using the Reactive Machine&amp;rsquo;s service builder definition. This builder will scan the current DLL and generate a service based on the definitions included.</description>
    </item>
    
    <item>
      <title>Echo Service</title>
      <link>http://reactive-machine.org/docs/examples-echo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/examples-echo/</guid>
      <description>Echo Service The Echo service example demonstrates how we can build an application that responds to events without the user having to consider failure, partitioning, routing messages or deployment details.
Affinity We begin by defining an affinity for the client and the server. We use the singleton affinities to route everything to a single node.
public interface IClientAffinity : ISingletonAffinity&amp;lt;IClientAffinity&amp;gt; { } public interface IServerAffinity : ISingletonAffinity&amp;lt;IServerAffinity&amp;gt; { } Events We define two events:</description>
    </item>
    
    <item>
      <title>Counter Service</title>
      <link>http://reactive-machine.org/docs/examples-counter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/examples-counter/</guid>
      <description>Counter Service The counter service example shows how you can leverage affinities at the application level for transparently routing messages and partitioning state for scalability without requiring the user to manually route messages or handle the partitioning of data themselves.
Events To begin designing our distributed counter, we start by modeling events that comprise the counter: increment events. These events are automatically partitioned using the ICounterAffinity affinity which requires that the event supply a partitioning key, CounterId.</description>
    </item>
    
    <item>
      <title>Orchestrations</title>
      <link>http://reactive-machine.org/docs/model-orchestrations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model-orchestrations/</guid>
      <description>Orchestrations are classes that define how to execute of one or more operations in their Execute method.
Orchestrations can easily express sequential and parallel composition as straight-line code. For example:
public class SequentialOrchestration : IOrchestration&amp;lt;int&amp;gt; { public async Task&amp;lt;int&amp;gt; Execute(IOrchestrationContext context) { int result1 = await context.Perform(...first operation...); int result2 = await context.Perform(...second operation...); return result1 + result2; } }public class ParallelOrchestration : IOrchestration&amp;lt;int&amp;gt; { public async Task&amp;lt;int&amp;gt; Execute(IOrchestrationContext context) { Task&amp;lt;int&amp;gt; task1 = context.</description>
    </item>
    
    <item>
      <title>Activities</title>
      <link>http://reactive-machine.org/docs/model-activities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model-activities/</guid>
      <description>Activities are classes that define how to execute some task in an Execute method, and may include nondeterminism and I/O.
Example 1 : Calling an External Service We can define an activity that reads the contents of a blob from Azure Storage:
public class ReadBlob : IAtLeastOnceActivity&amp;lt;string&amp;gt; { // the input to the activity  public string Path; // must specify a time limit  public TimeSpan TimeLimit =&amp;gt; TimeSpan.</description>
    </item>
    
    <item>
      <title>States</title>
      <link>http://reactive-machine.org/docs/model-states/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model-states/</guid>
      <description>States represent a small piece of information (cf. key-value pair, or a grain, or virtual actor) that can be atomically accessed via a specified set of read and update operations.
(section needs work)
Example 1: Bank Customer State We start by defining an affinity for how our data should be partitioned. To do this, we implement an affinity based on the users identity.
namespace Bank.Service { public interface IUserAffinity : IPartitionedAffinity&amp;lt;IUserAffinity,string&amp;gt; { string UserId { get; } } } We create an event that our state will subscribe to: the UserSignedUp event.</description>
    </item>
    
    <item>
      <title>Affinities</title>
      <link>http://reactive-machine.org/docs/model-affinities/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/model-affinities/</guid>
      <description>Affinities define locality, by specifying keys that can be used to place state, orchestrations, and activities. These keys are also used for synchronization (locking). Events provide reliable, consistent pub-sub. When an event is raised by an orchestration, all the states that subscribe to it are modified. Events appear to be globally ordered and virtually synchronous.
(section needs work)
Singletons If we wish to place an object in only one location, the ISingletonAffinity interface can be used to force placement only at a single partition.</description>
    </item>
    
    <item>
      <title>EmulatorHost</title>
      <link>http://reactive-machine.org/docs/hosts-emulatorhost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/hosts-emulatorhost/</guid>
      <description>(section needs work)</description>
    </item>
    
    <item>
      <title>FunctionsHost</title>
      <link>http://reactive-machine.org/docs/hosts-functionshost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/hosts-functionshost/</guid>
      <description>(section needs work)</description>
    </item>
    
    <item>
      <title>ApplicationBuilder</title>
      <link>http://reactive-machine.org/docs/hosts-applicationbuilder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/hosts-applicationbuilder/</guid>
      <description>(section needs work)</description>
    </item>
    
    <item>
      <title>Serialization</title>
      <link>http://reactive-machine.org/docs/hosts-serialization/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://reactive-machine.org/docs/hosts-serialization/</guid>
      <description>(section needs work)
In the code, all of the entities (Orchestrations, States, Affinities, Activities, Reads, Updates, Events) and all return value types must be serializable classes. This allows the runtim to perform Serialization as needed to persist all states and orchestration progress durably and recover them automatically after machine or connection failures.</description>
    </item>
    
  </channel>
</rss>